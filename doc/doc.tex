\documentclass{article}
    % General document formatting
    \usepackage[margin=0.7in]{geometry}
    \usepackage[parfill]{parskip}
    \usepackage[utf8]{inputenc}

    % bibtex
    \usepackage{biblatex}
    \bibliography{doc}

    \usepackage{blindtext, hyperref}
    \usepackage{amsmath,amssymb,amsfonts,amsthm, mathtools}
    \usepackage{listings,xcolor,caption}

    \newcommand{\divides}{\mid}
    \newcommand{\notdivides}{\nmid}

    \definecolor{codegreen}{rgb}{0,0.6,0}
    \definecolor{codegray}{rgb}{0.5,0.5,0.5}
    \definecolor{codepurple}{rgb}{0.58,0,0.82}
    \definecolor{backcolour}{rgb}{0.95,0.95,0.92}

    \lstdefinestyle{mystyle} {
        backgroundcolor=\color{backcolour},
        commentstyle=\color{codegreen},
        keywordstyle=\color{magenta},
        numberstyle=\tiny\color{codegray},
        stringstyle=\color{codepurple},
        basicstyle=\ttfamily\footnotesize,
        breakatwhitespace=false,
        breaklines=true,
        captionpos=b,
        keepspaces=true,
        numbers=left,
        numbersep=5pt,
        showspaces=false,
        showstringspaces=false,
        showtabs=false,
        tabsize=2,
        escapeinside={tex(}{tex)}
    }
    \lstset{style=mystyle}
    \renewcommand{\lstlistingname}{Algoritmo}

    \DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

    \title{Trabalho 02 - Álgebra A}
    \author{Luis Higino, Mateus Vitor}

\begin{document}

\maketitle

\section{Introdução}
\label{intro}
O presente documento tem como objetivo explicar a implementação dos algoritmos utilizados para resolver os seguintes problemas:
\begin{itemize}
    \item Resolver sistemas de equações lineares sobre o $\mathbb{Z}_2$.
    \item Encontrar as soluções da congruência quadrática $x^2 \equiv n \pmod{p}$.
    \item Fatorar um número $N \gg 0$ em dois fatores não triviais.
\end{itemize} 
\section{Desenvolvimento}

O trabalho foi desenvolvido na linguagem \href{https://www.haskell.org/}{Haskell}, utilizando do tipo padrão \verb| Integer | para armazenar inteiros de precisão arbitrária. O código fonte do trabalho pode ser encontrado neste repositório do GitHub:
\\\verb|https://github.com/mateusvmv/tp2_algebra_a|.

\section{Módulos}

Os módulos do código fonte são

\begin{itemize}
\item Matrix: Implementa o algoritmo de resolução de sistemas lineares no $\mathbb{Z}_2$.
\item Numbers: Implementa os algoritmos de teoria dos números, como o gerador de primos, o algoritmo de Tonelli-Shanks, etc.
\item Sieve: Implementa o algoritmo do Crivo Quadrático para fatoração.
\item Main: O módulo principal do programa, que utiliza de todos os acima.
\end{itemize}

\section{Formatos de Entrada e Saída}

\subsection{Entrada}

A entrada é lida da entrada padrão \verb|stdin|. Ou seja, após rodar o programa o usuário digita com o teclado um inteiro positivo $N \gg 0$.

\subsection{Saída}

A saída do programa informa:

\begin{enumerate}
    \item O limite de fatoração $B$.
    \item A quantidade de primos utilizada na fatoração $B$-smooth.
    \item Dois inteiros $x, y$ tais que $x \not\equiv y \pmod{N}$ e $x^2 \equiv y^2 \pmod{N}$.
    \item Dois fatores não triviais de $N$.
\end{enumerate}

O programa iterativamente tenta fatorar o número com limites de fatorações difeerentes, a saída do programa informa ao usuário as tentativas feitas e seus resultados até que uma resulte em uma fatoração não trivial bem sucedida.

\section{Utilização do Programa}

Para utilizar o programa, primeiro instale o GHC. Caso o sistema seja Windows ou Linux, siga \href{https://www.haskell.org/downloads/}{esse tutorial}.

Com o GHC instalado, abra um terminal no diretório raíz do código fonte e execute:

\verb|ghc -O3 -o Main -isrc|

Agora, basta executar o binário \verb|Main| e em seguida digitar o inteiro de entrada, seguido por um \textit{Enter}.

\section{Análises de Complexidade}

Muitos dos algoritmos, especialmente os do módulo |Numbers|, foram reaproveitados do Trabalho Prático 1. Logo, vamos discutir aqui apenas os algoritmos implementados exclusivamente para este trabalho.

\subsection{Algoritmo de Tonelli-Shanks}
\label{tonelliShanks}

O algoritmo de \textit{Tonelli-Shanks} tem como objetivo encontrar as 2 soluções para a equação
\begin{equation}
    x^2 \equiv n \pmod{p}
\end{equation}

Para isso, ele utiliza do \textbf{Critério de Euler}. Ele diz que $n$ tem uma raíz quadrada módulo $p$ se e somente se:

\begin{equation}
    n^{\frac{p-1}{2}} \equiv 1 \pmod{p}
\end{equation}

Além disso, o critério diz que quando $n$ não possui uma raíz quadrada módulo $p$, a seguinte equação vale:
\begin{equation}
    n^{\frac{p-1}{2}} \equiv -1 \pmod{p}
\end{equation}

O algoritmo então procede sa seguinte forma:
\begin{enumerate}
    \item Encontra $S$ e $Q$ tais que $p-1 = 2^S \cdot Q$ em $O(\log p)$.
    \item Encontra um $z$ tal que $z^{\frac{p-1}{2}} \equiv -1 \pmod{p}$ em $O(\log p)$.
    \item Iterativamente encontra a "ordem" (é considerado apenas expoentes potências de 2) de $n$ no grupo multiplicativo de $\mathbb{Z} / \mathbb{Z}_p$.
\end{enumerate}

A complexidade final do pior caso do algoritmo é $O(\log^4 p)$, mas o número esperado de iterações são apenas 2, logo a complexidade esperada é apenas $O(\log p)$~\cite{Koo_Jo_Kwon_2013}.

\begin{minipage}{.9\linewidth}
\begin{lstlisting}[language=haskell,caption=Tonelli-Shanks]
tonelli :: Integer -> Integer -> Maybe (Integer, Integer)
tonelli n p
    | p <= 2 = Just (mod n 2, mod n 2)
    | legendre n p == 1 = Just (r, p - r)
    | otherwise = Nothing
    where
    pow = powMod p
    (s, q) = justFind (odd . snd) $ iterate (bimap (+1) (.>>. 1)) (0, p-1)
    z = (+ 1) . last $ takeWhile (\i -> legendre i p + 1 /= p) [1..p-1]
    initial = (s, pow z q, pow n $ (q+1) .>>. 1, pow n q)
    step (m, c, r, t) = (i, c', r', t') where
        i = fst . justFind ((==1) . snd) $ iterate (bimap (+ 1) (`pow` 2)) (0, t)
        b = pow c (shiftL 1 (m - i - 1))
        r' = mod (r*b) p
        c' = mod (b*b) p
        t' = mod (t*c') p
    condition (_, _, _, t) = mod (t - 1) p == 0
    (_,_,r,_) = justFind condition (iterate step initial)

\end{lstlisting}
\end{minipage}

\subsection{Resolução de Sistemas Lineares}
\label{matrixSolver}

Para a resolução de Sistemas Lineares, foi implementado o algoritmo da Eliminação Gaussiana para matrizes com entradas no $\mathbb{Z}_2$.

A complexidade aritmética desse algoritmo é $O(n^3)$~\cite{Farebrother_1988}, onde $n$ é a quantidade de variáveis do sistema.
Isso ocorre pois a cada passo da eliminação, é necessário percorrer toda a matriz para zerar os elementos abaixo do pivô.
Como as entradas são binárias, as operações aritméticas do algoritmo são de fato constantes e a complexidade acima é a complexidade de tempo total.

\begin{minipage}{.9\linewidth}
\begin{lstlisting}[language=haskell,caption=Eliminação Gaussiana]
upperEchelon :: UArray (Int, Int) Bool -> UArray (Int, Int) Bool
upperEchelon mat = listArray ((0, 0), (lines, cols)) (concatMap elems . reverse $ psList) where
    (lines, cols) = snd $ bounds mat
    lineList = [listArray (0, cols) [mat!(i,j) | j <- [0..cols]] | i <- [0..lines]]
    findPivot [] _ = (Nothing, [])
    findPivot (r:rs) k
        | r!k = (Just r, rs)
        | otherwise = (r', r:mat') where (r', mat') = findPivot rs k
    takePivot p k r = if r!k then listArray (0, cols) [xor (r!j) (p!j) | j <- [0..cols]] else r
    nextPivot :: ([UArray Int Bool], [UArray Int Bool]) -> Int -> ([UArray Int Bool], [UArray Int Bool])
    nextPivot (lines, ps) k = case findPivot lines k of
        (Just p, mat') -> (map (takePivot p k) mat', p:ps)
        (Nothing, mat') -> (mat', array (0, cols) []:ps)
    (_, psList) = foldl nextPivot (lineList, []) [0..cols]

solve :: UArray (Int, Int) Bool -> UArray Int Bool
solve mat = trace ("Resolvendo matriz de tamanho " ++ show (snd $ bounds mat)) s where
    ue = upperEchelon mat
    (lines, cols) = snd $ bounds ue
    solveLine :: UArray Int Bool -> Int -> UArray Int Bool
    solveLine s i
        -- Unbound pivot or even amount of set variables, ignore
        | not (ue!(i,i)) || even = s
        -- The pivot is set because it must complement the set variables and result in zero
        | otherwise = s // [(i, True)]
        where even = foldl xor True [ue!(i,j) && s!j | j <- [i+1..cols]]
    unbound = filter (not . (ue!) . \i -> (i, i)) [0..min lines cols]
    start = array (0, cols) $ map (,True) unbound
    s = foldl solveLine start (reverse [0..min lines cols])

\end{lstlisting}
\end{minipage}

\subsection{Crivo Quadrático}
\label{quadraticSieve}

\subsection{Crivo dos Candidatos}
\label{sieve}

% TODO: Nome melhor
\subsection{Merge}
\label{merge}

Para pré-calcular uma lista de primos pequenos, utilizamos do algoritmo do \textbf{Crivo de Eratóstenes}. Em particular, utilizamos uma versão com um consumo menor de memória, o crivo \textit{segmentado}, mas o princípio e complexidade são as mesmas da versão clássica e ela será explicada aqui.

Inicializamos a lista de primos com o $2$ e um vetor de booleanos, assumindo a priori que todos os números são primos, menos o $1$. Em seguida, percorremos os números de $3$ até um certo limite $N$, com passos de $+2$ pois nenhum número par diferente de 2 é primo. Por fim, toda vez que chegamos em um número checamos se ele já foi marcado como não primo. Se sim, continuamos, se não adicionamos ele na lista e marcamos todos os seus múltiplos como não primos. Esse algoritmo tem complexidade $O(\sum_{p \leq n} \frac{n}{p}) = O(n \cdot \sum_{p \leq n}\frac{1}{p})$. Não será demonstrado aqui, mas isso é $O(n \cdot \log \log n)$.

\begin{minipage}{0.9\linewidth}
\begin{lstlisting}[language=haskell,caption=Crivo de Eratóstenes e Lista dos primos]
-- Crivo Segmentado
sieveSeg a' b' ps = [i*2+1 | i <- [a..b], coprime ! i] where
a = shiftR a' 1; b = shiftR b' 1
muls p = [l, l+p .. b] where l = shiftR (p * ((a'+p-1) `div` p .|. 1)) 1
coprime = accumArray (\_ b -> b) True (a, b) (map (,False) $ concatMap muls ps) :: UArray Integer Bool

-- Lista dos Primos
primes :: [Integer] = [2,3] ++ sieve 5 where
sieve n = sieveSeg n top ps ++ sieve (top+2) where
    top = min (n + 2^15) (2 + n*n - 4*n)
    ps = takeWhile (\p -> p*p < top) (tail primes)
\end{lstlisting}
\end{minipage}

Observe que aqui definimos um limite para o crivo, ou seja, o $n$-ésimo primo que é calculado em tempo hábil:

\begin{minipage}{0.9\linewidth}
\begin{lstlisting}[language=haskell,caption=Limite do Crivo]
softLimit :: Integer = 2^20
\end{lstlisting}
\end{minipage}

\section{Referências}

\printbibliography


\end{document}