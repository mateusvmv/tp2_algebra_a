\documentclass{article}
    % General document formatting
    \usepackage[margin=0.7in]{geometry}
    \usepackage[parfill]{parskip}
    \usepackage[utf8]{inputenc}

    \usepackage{blindtext, hyperref}
    \usepackage{amsmath,amssymb,amsfonts,amsthm, mathtools}
    \usepackage{listings,xcolor,caption}

    \newcommand{\divides}{\mid}
    \newcommand{\notdivides}{\nmid}

    \definecolor{codegreen}{rgb}{0,0.6,0}
    \definecolor{codegray}{rgb}{0.5,0.5,0.5}
    \definecolor{codepurple}{rgb}{0.58,0,0.82}
    \definecolor{backcolour}{rgb}{0.95,0.95,0.92}

    \lstdefinestyle{mystyle} {
        backgroundcolor=\color{backcolour},
        commentstyle=\color{codegreen},
        keywordstyle=\color{magenta},
        numberstyle=\tiny\color{codegray},
        stringstyle=\color{codepurple},
        basicstyle=\ttfamily\footnotesize,
        breakatwhitespace=false,
        breaklines=true,
        captionpos=b,
        keepspaces=true,
        numbers=left,
        numbersep=5pt,
        showspaces=false,
        showstringspaces=false,
        showtabs=false,
        tabsize=2,
        escapeinside={tex(}{tex)}
    }
    \lstset{style=mystyle}
    \renewcommand{\lstlistingname}{Algoritmo}

    \DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

    \title{Trabalho 02 - Álgebra A}
    \author{Luis Higino, Mateus Vitor}

\begin{document}

\maketitle

\section{Introdução}
\label{intro}
O presente documento tem como objetivo explicar a implementação dos algoritmos utilizados para resolver os seguintes problemas:
\begin{itemize}
    \item Resolver sistemas de equações lineares sobre o $\mathbb{Z}_2$.
    \item Encontrar as soluções da congruência quadrática $x^2 \equiv n \pmod{p}$.
    \item Fatorar um número $N \gg 0$ em dois fatores não triviais.
\end{itemize} 
\section{Desenvolvimento}

O trabalho foi desenvolvido na linguagem \href{https://www.haskell.org/}{Haskell}, utilizando do tipo padrão \verb| Integer | para armazenar inteiros de precisão arbitrária. O código fonte do trabalho pode ser encontrado neste repositório do GitHub:
\\\verb|https://github.com/mateusvmv/tp2_algebra_a|.

\section{Módulos}

Os módulos do código fonte são

\begin{itemize}
\item Matrix: Implementa o algoritmo de resolução de sistemas lineares no $\mathbb{Z}_2$.
\item Numbers: Implementa os algoritmos de teoria dos números, como o gerador de primos, o algoritmo de Tonelli-Shanks, etc.
\item Sieve: Implementa o algoritmo do Crivo Quadrático para fatoração.
\item Main: O módulo principal do programa, que utiliza de todos os acima.
\end{itemize}

\section{Formatos de Entrada e Saída}

\subsection{Entrada}

A entrada é lida da entrada padrão \verb|stdin|. Ou seja, após rodar o programa o usuário digita com o teclado um inteiro positivo $N \gg 0$.

\subsection{Saída}

A saída do programa informa:

\begin{enumerate}
    \item O limite de fatoração $B$.
    \item A quantidade de primos utilizada na fatoração $B$-smooth.
    \item Dois inteiros $x, y$ tais que $x \not\equiv y \pmod{N}$ e $x^2 \equiv y^2 \pmod{N}$.
    \item Dois fatores não triviais de $N$.
\end{enumerate}

O programa iterativamente tenta fatorar o número com limites de fatorações difeerentes, a saída do programa informa ao usuário as tentativas feitas e seus resultados até que uma resulte em uma fatoração não trivial bem sucedida.

\section{Utilização do Programa}

Para utilizar o programa, primeiro instale o GHC. Caso o sistema seja Windows ou Linux, siga \href{https://www.haskell.org/downloads/}{esse tutorial}.

Com o GHC instalado, abra um terminal no diretório raíz do código fonte e execute:

\verb|ghc -O3 -o Main -isrc|

Agora, basta executar o binário \verb|Main| e em seguida digitar o inteiro de entrada, seguido por um \textit{Enter}.

\section{Análises de Complexidade}

Muitos dos algoritmos, especialmente os do módulo |Numbers|, foram reaproveitados do Trabalho Prático 1. Logo, vamos discutir aqui apenas os algoritmos implementados exclusivamente para este trabalho.

\subsection{Algoritmo de Tonelli-Shanks}
\label{tonelliShanks}

O algoritmo de exponenciação binária é utilizado para calcular $a^b \bmod p$, com $a, b, p \in \mathbb{Z}$. O algoritmo utiliza da seguinte recorrência:

\begin{align*}
  a^b \bmod p = \begin{cases}
    1 & \text{se } b = 0 \\
    {(a^{b/2})}^2 & \text{se } b \bmod 2 = 0 \\
    a \cdot {(a^{(b-1)/2})}^2 & \text{se } b \bmod 2 = 1 \\
\end{cases}
\end{align*}

A cada 2 passos da recorrência, o valor de $b$ diminui, pelo menos, pela metade. A recorrência para quando $b = 0$ e as transições são todas constantes, logo a complexidade de tempo do algoritmo é $O(\log_2 b)$.

\begin{minipage}{.9\linewidth}
\begin{lstlisting}[language=haskell,caption=Exponenciação Binária]
binExp :: Integer -> Integer -> Integer -> Integer
binExp a b p = f' 1 a b where
    f' r a b
        | b == 0 = r
        | odd b = f' (r*a `mod` p) (a^2 `mod` p) (shiftR b 1)
        | otherwise = f' r (a^2 `mod` p) (shiftR b 1)

\end{lstlisting}
\end{minipage}

\subsection{Resolução de Sistemas Lineares}
\label{matrixSolver}

O algoritmo extendido de Euclides calcula, para entradas $a, b \in \mathbb{Z}$, a tripla $(g, x, y) \in \mathbb{Z} \times \mathbb{Z} \times \mathbb{Z}$ tal que:

\begin{align*}
  g & = \text{mdc}(a, b) \\
  g & = a \cdot x + b \cdot y \\
\end{align*}

Para isso, ele utiliza a seguinte recorrência

\begin{align*}
  \text{emdc}(a, b) = \begin{cases}
    (a, 1, 0) & \text{se } b = 0 \\
    (g, y, x - y \cdot q) & \text{c.c. }, \text{ onde } q \cdot a + r = b, (g, x, y) = \text{emdc}(b, r) \\
\end{cases}
\end{align*}

A cada dois passos da recorrência, o maior valor diminui pelo menos pela metade, pois $\forall a, b \in \mathbb{N} \colon a \geq b \implies a \bmod b \leq \frac{a}{2}$. Logo, a complexidade total do algoritmo é $O(\log_2(\max (a, b)))$.

Em particular, o Algoritmo Extendido de Euclides é utilizado para calcular o \textbf{Inverso Modular} de um inteiro $a \bmod m$. Para isso, basta calcular o $x$ tal que $ax + my = \text{mdc(a, m)}$ já que se $a$ é inversível, $\text{mdc}(a, m) = 1$ e $x \bmod m$ é seu inverso modular.


\begin{minipage}{.9\linewidth}
\begin{lstlisting}[language=haskell,caption=Algoritmo Extendido de Euclides]
egcd :: Integer -> Integer -> (Integer, Integer, Integer)
egcd a 0 = (a, 1, 0)
egcd a b =
    let (g, x1, y1) = egcd b r
    in (g, y1, x1 - y1 * q)
        where
            (q, r) = divMod a b
\end{lstlisting}
\end{minipage} \\
Observe que a implementação para encontrar o inverso modular de um número é apenas uma chamada ao algoritmo extendido de Euclides.

\begin{minipage}{.9\linewidth}
\begin{lstlisting}[language=haskell,caption=Inverso Modular]
invMod :: Integer -> Integer -> Integer
invMod a m =
    let (g, x, y) = egcd a m
    in case g of
        1 -> (x `mod` m + m) `mod` m
        _ -> error $ "invMod expects coprime numbers, received " ++ show a ++ " " ++ show m
\end{lstlisting}
\end{minipage}

\subsection{Crivo Quadrático}
\label{quadraticSieve}

\subsection{Crivo dos Candidatos}
\label{sieve}

% TODO: Nome melhor
\subsection{Merge}
\label{merge}

Para pré-calcular uma lista de primos pequenos, utilizamos do algoritmo do \textbf{Crivo de Eratóstenes}. Em particular, utilizamos uma versão com um consumo menor de memória, o crivo \textit{segmentado}, mas o princípio e complexidade são as mesmas da versão clássica e ela será explicada aqui.

Inicializamos a lista de primos com o $2$ e um vetor de booleanos, assumindo a priori que todos os números são primos, menos o $1$. Em seguida, percorremos os números de $3$ até um certo limite $N$, com passos de $+2$ pois nenhum número par diferente de 2 é primo. Por fim, toda vez que chegamos em um número checamos se ele já foi marcado como não primo. Se sim, continuamos, se não adicionamos ele na lista e marcamos todos os seus múltiplos como não primos. Esse algoritmo tem complexidade $O(\sum_{p \leq n} \frac{n}{p}) = O(n \cdot \sum_{p \leq n}\frac{1}{p})$. Não será demonstrado aqui, mas isso é $O(n \cdot \log \log n)$.

\begin{minipage}{0.9\linewidth}
\begin{lstlisting}[language=haskell,caption=Crivo de Eratóstenes e Lista dos primos]
-- Crivo Segmentado
sieveSeg a' b' ps = [i*2+1 | i <- [a..b], coprime ! i] where
a = shiftR a' 1; b = shiftR b' 1
muls p = [l, l+p .. b] where l = shiftR (p * ((a'+p-1) `div` p .|. 1)) 1
coprime = accumArray (\_ b -> b) True (a, b) (map (,False) $ concatMap muls ps) :: UArray Integer Bool

-- Lista dos Primos
primes :: [Integer] = [2,3] ++ sieve 5 where
sieve n = sieveSeg n top ps ++ sieve (top+2) where
    top = min (n + 2^15) (2 + n*n - 4*n)
    ps = takeWhile (\p -> p*p < top) (tail primes)
\end{lstlisting}
\end{minipage}

Observe que aqui definimos um limite para o crivo, ou seja, o $n$-ésimo primo que é calculado em tempo hábil:

\begin{minipage}{0.9\linewidth}
\begin{lstlisting}[language=haskell,caption=Limite do Crivo]
softLimit :: Integer = 2^20
\end{lstlisting}
\end{minipage}


\end{document}